{"version":3,"file":"index.umd.js","sources":["../src/slice/types.ts","../src/slice/trrackableSliceCreator.ts","../src/slice/utils.ts","../src/store/trrackStore.ts","../src/store/trrackableStoreCreator.ts","../src/store/utils.ts"],"sourcesContent":["import {\n  ActionCreatorWithPayload,\n  AsyncThunk,\n  CaseReducerActions,\n  createAction,\n  PayloadAction,\n  PayloadActionCreator,\n  Slice,\n  SliceCaseReducers,\n} from '@reduxjs/toolkit';\nimport { Label, LabelGenerator } from '@trrack/core';\n\nexport type LabelLike<CaseReducers extends SliceCaseReducers<any>> = Partial<{\n  [K in keyof CaseReducerActions<CaseReducers, any>]: CaseReducerActions<\n    CaseReducers,\n    any\n  >[K] extends PayloadActionCreator<infer P>\n    ? Label | LabelGenerator<P>\n    : never;\n}>;\n\nexport type LabelGenerators = {\n  [key: string]: LabelGenerator<any>;\n};\n\n/**\n * Events\n */\nexport type ReducerEventTypes<\n  Event extends string,\n  CaseReducers extends SliceCaseReducers<any>\n> = {\n  [K in keyof CaseReducerActions<CaseReducers, any>]: Event;\n};\n\n/**\n * Action Name and Type map\n */\n\nexport type ActionNameToTypeMap<\n  CaseReducers extends SliceCaseReducers<any>,\n  CRA extends CaseReducerActions<CaseReducers, any> = CaseReducerActions<\n    CaseReducers,\n    any\n  >\n> = {\n  [K in keyof CRA]: CRA[K] extends ActionCreatorWithPayload<any, infer T>\n    ? T\n    : never;\n};\n\n/**\n * Do Undo Action Creators\n */\nexport const NO_OP_ACTION = createAction('NO_OP');\n\ntype NoOpActionType = typeof NO_OP_ACTION;\n\ntype DoUndoActionCreator<\n  Payload,\n  DoPayload = Payload,\n  UndoPayload = DoPayload\n> = (args: {\n  action: PayloadAction<Payload>;\n  currentState: any;\n  previousState: any;\n}) => {\n  do?: NoOpActionType | PayloadAction<DoPayload>;\n  undo: NoOpActionType | PayloadAction<UndoPayload>;\n};\n\nexport type DoUndoActionCreators<CaseReducers extends SliceCaseReducers<any>> =\n  Partial<{\n    [key: string]: DoUndoActionCreator<any, any, any>;\n    // [K in keyof CaseReducerActions<CaseReducers>]: CaseReducerActions<CaseReducers>[K] extends PayloadActionCreator<\n    //   infer P\n    // >\n    //   ? DoUndoActionCreator<P, any, any>\n    //   : never;\n  }>;\n\nexport type GeneratedDoUndoActionCreators = {\n  [key: string]: (\n    args: Parameters<DoUndoActionCreator<any, any, any>>[0]\n  ) => Required<ReturnType<DoUndoActionCreator<any, any, any>>>;\n};\n\nexport const LABELS = Symbol('label');\nexport const DO_UNDO_ACTION_CREATORS = Symbol('do_undo_action_creators');\nexport const TRRACKABLE = Symbol('trrackable');\nexport const EVENTS = Symbol('events');\nexport const ACTION_NAME_TYPE_MAP = Symbol('action_name_type_map');\nexport const ASYNC_THUNKS = Symbol('async_thunks');\n\nexport type TrrackableSlice<\n  State,\n  CaseReducers extends SliceCaseReducers<State>,\n  Event extends string = string,\n  Name extends string = string\n> = Slice<State, CaseReducers, Name> & {\n  [LABELS]: LabelGenerators;\n  [EVENTS]: ReducerEventTypes<Event, CaseReducers>;\n  [TRRACKABLE]: boolean;\n  [DO_UNDO_ACTION_CREATORS]: GeneratedDoUndoActionCreators;\n  [ACTION_NAME_TYPE_MAP]: ActionNameToTypeMap<CaseReducers>;\n  [ASYNC_THUNKS]: Array<AsyncThunk<any, any, any>>;\n};\n","import {\n  AsyncThunk,\n  CaseReducerActions,\n  createSlice,\n  CreateSliceOptions,\n  PayloadAction,\n  PayloadActionCreator,\n  Slice,\n  SliceCaseReducers,\n} from '@reduxjs/toolkit';\n\nimport {\n  ACTION_NAME_TYPE_MAP,\n  ActionNameToTypeMap,\n  ASYNC_THUNKS,\n  DO_UNDO_ACTION_CREATORS,\n  DoUndoActionCreators,\n  EVENTS,\n  GeneratedDoUndoActionCreators,\n  LabelGenerators,\n  LabelLike,\n  LABELS,\n  NO_OP_ACTION,\n  ReducerEventTypes,\n  TRRACKABLE,\n  TrrackableSlice,\n} from './types';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createNameToTypeMap<\n  CaseReducers extends SliceCaseReducers<any>,\n  S extends Slice<any, CaseReducers, any>\n>(slice: S) {\n  const actionNameToType = {} as ActionNameToTypeMap<CaseReducers>;\n\n  Object.entries(slice.actions).forEach(\n    ([key, action]: [\n      keyof CaseReducerActions<CaseReducers, any>,\n      PayloadActionCreator<any>\n    ]) => {\n      actionNameToType[key] =\n        action.type as ActionNameToTypeMap<CaseReducers>[typeof key];\n    }\n  );\n\n  return actionNameToType;\n}\n\nfunction normalizeLabelGenerators<\n  CaseReducers extends SliceCaseReducers<any>,\n  S extends Slice<any, CaseReducers, any>\n>(\n  slice: S,\n  suppliedLabelLikes: LabelLike<CaseReducers>,\n  thunks: Array<AsyncThunk<any, any, any>>\n): LabelGenerators {\n  const labelGenerators: LabelGenerators = {};\n\n  thunks.forEach((thunk) => {\n    const key = thunk.typePrefix;\n    const suppliedLabelLike = suppliedLabelLikes[key];\n\n    if (!suppliedLabelLike) {\n      labelGenerators[key] = () => key;\n      return;\n    }\n\n    if (typeof suppliedLabelLike === 'string') {\n      labelGenerators[key] = () => suppliedLabelLike;\n      return;\n    }\n\n    if (typeof suppliedLabelLike === 'function') {\n      labelGenerators[key] = suppliedLabelLike;\n    }\n\n    throw new Error(`Error creating label generator for ${key.toString()}`);\n  });\n\n  Object.entries(slice.actions).forEach(\n    ([key, action]: [\n      keyof CaseReducerActions<CaseReducers, any>,\n      PayloadActionCreator<any>\n    ]) => {\n      const suppliedLabelLike = suppliedLabelLikes[key];\n\n      if (!suppliedLabelLike) {\n        labelGenerators[action.type] = () => action.type;\n        return;\n      }\n\n      if (typeof suppliedLabelLike === 'string') {\n        labelGenerators[action.type] = () => suppliedLabelLike;\n        return;\n      }\n\n      if (typeof suppliedLabelLike === 'function') {\n        labelGenerators[action.type] = suppliedLabelLike;\n        return;\n      }\n\n      throw new Error(\n        `Error creating label generator for ${key.toString()}: ${action.type}`\n      );\n    }\n  );\n\n  return labelGenerators;\n}\n\nfunction createReducerEventTypes<\n  Event extends string,\n  CaseReducers extends SliceCaseReducers<any>,\n  S extends Slice<any, CaseReducers, any>\n>(\n  slice: S,\n  suppliedEventTypes: Partial<ReducerEventTypes<Event, CaseReducers>>,\n  thunks: Array<AsyncThunk<any, any, any>>\n): ReducerEventTypes<Event, CaseReducers> {\n  const reducerEventTypes: any = {};\n\n  thunks.forEach((thunk) => {\n    const key = thunk.typePrefix;\n    const suppliedEventType = suppliedEventTypes[key];\n\n    if (!suppliedEventType) {\n      reducerEventTypes[key] = key;\n    } else {\n      reducerEventTypes[key] = suppliedEventType;\n    }\n  });\n\n  Object.entries(slice.actions).forEach(\n    ([key, action]: [\n      keyof CaseReducerActions<CaseReducers, any>,\n      PayloadActionCreator<any>\n    ]) => {\n      const suppliedEventType = suppliedEventTypes[key];\n\n      if (!suppliedEventType) reducerEventTypes[action.type] = action.type;\n      else reducerEventTypes[action.type] = suppliedEventType;\n    }\n  );\n\n  return reducerEventTypes as ReducerEventTypes<Event, CaseReducers>;\n}\n\nfunction createDoUndoActionCreators<\n  State,\n  CaseReducers extends SliceCaseReducers<any>\n>(\n  slice: Slice<State, CaseReducers, any>,\n  suppliedDoUndoActionCreators: DoUndoActionCreators<CaseReducers>,\n  thunks: Array<AsyncThunk<any, any, any>>\n): GeneratedDoUndoActionCreators {\n  const duac: GeneratedDoUndoActionCreators = {};\n\n  thunks.forEach((thunk) => {\n    const key = thunk.typePrefix;\n\n    const suppliedDoUndoActionCreator = suppliedDoUndoActionCreators[key];\n\n    if (!suppliedDoUndoActionCreator) {\n      const act = () => {\n        return {\n          do: NO_OP_ACTION(),\n          undo: NO_OP_ACTION(),\n        };\n      };\n      duac[key] = act;\n    } else {\n      const act = (args: {\n        action: PayloadAction;\n        previousState: State;\n        currentState: State;\n      }) => {\n        const { do: doAct, undo } = suppliedDoUndoActionCreator(args);\n\n        return {\n          do: doAct ? doAct : NO_OP_ACTION(),\n          undo,\n        };\n      };\n\n      duac[key] = act;\n    }\n  });\n\n  Object.entries(slice.actions).forEach(\n    <K extends keyof CaseReducerActions<CaseReducers, any>>([key, action]: [\n      K,\n      Exclude<CaseReducerActions<CaseReducers, any>[K], void>\n    ]) => {\n      const suppliedDoUndoActionCreator =\n        suppliedDoUndoActionCreators[key as string];\n      if (!suppliedDoUndoActionCreator) {\n        duac[action.type] = () => {\n          return {\n            do: NO_OP_ACTION(),\n            undo: NO_OP_ACTION(),\n          };\n        };\n      } else {\n        duac[action.type] = (args: {\n          action: PayloadAction;\n          previousState: State;\n          currentState: State;\n        }) => {\n          const { do: doAct, undo } = suppliedDoUndoActionCreator(args);\n\n          return {\n            do: doAct ? doAct : NO_OP_ACTION(),\n            undo,\n          };\n        };\n      }\n    }\n  );\n\n  return duac;\n}\n\nexport function createTrrackableSlice<\n  State,\n  CaseReducers extends SliceCaseReducers<State>,\n  Event extends string = string,\n  Name extends string = string\n>(\n  options: CreateSliceOptions<State, CaseReducers, Name> & {\n    labels?: LabelLike<CaseReducers>;\n    reducerEventTypes?: Partial<ReducerEventTypes<Event, CaseReducers>>;\n    doUndoActionCreators?: DoUndoActionCreators<CaseReducers>;\n    asyncThunks?: Array<AsyncThunk<any, any, any>>;\n  }\n): TrrackableSlice<State, CaseReducers, Event, Name> {\n  const slice = createSlice(options);\n\n  const actionNameToType: ActionNameToTypeMap<CaseReducers> =\n    createNameToTypeMap(slice);\n\n  const labels = normalizeLabelGenerators(\n    slice,\n    options.labels || {},\n    options.asyncThunks || []\n  );\n\n  const reducerEventTypes = createReducerEventTypes(\n    slice,\n    options.reducerEventTypes || {},\n    options.asyncThunks || []\n  );\n\n  const doUndoActioncreators = createDoUndoActionCreators(\n    slice,\n    options.doUndoActionCreators || {},\n    options.asyncThunks || []\n  );\n\n  return {\n    ...slice,\n    [LABELS]: labels,\n    [EVENTS]: reducerEventTypes,\n    [DO_UNDO_ACTION_CREATORS]: doUndoActioncreators,\n    [TRRACKABLE]: true,\n    [ACTION_NAME_TYPE_MAP]: actionNameToType,\n    [ASYNC_THUNKS]: options.asyncThunks || [],\n  };\n}\n","import { Slice } from '@reduxjs/toolkit';\n\nimport { TRRACKABLE, TrrackableSlice } from './types';\n\nexport function isSliceTrrackable(\n  slice: Slice\n): slice is TrrackableSlice<any, any> {\n  return TRRACKABLE ? TRRACKABLE in slice : false;\n}\n","import { configureStore, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { NodeId } from '@trrack/core';\n\ntype TrrackSliceState = {\n  current: NodeId;\n};\n\nconst initialState: TrrackSliceState = {\n  current: null as any,\n};\n\nconst trrackSlice = createSlice({\n  name: 'trrack',\n  initialState,\n  reducers: {\n    changeCurrent: (_, action: PayloadAction<NodeId>) => ({\n      current: action.payload,\n    }),\n  },\n});\n\nexport const { changeCurrent } = trrackSlice.actions;\n\nexport function getTrrackStore(init: TrrackSliceState) {\n  return configureStore({\n    reducer: trrackSlice.reducer,\n    preloadedState: init as any,\n  });\n}\n\ntype TrrackStore = ReturnType<typeof getTrrackStore>;\n\nexport type TrrackStoreType = ReturnType<TrrackStore['getState']>;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  Action,\n  AnyAction,\n  AsyncThunk,\n  combineReducers,\n  configureStore,\n  ConfigureStoreOptions,\n  createAction,\n  createListenerMiddleware,\n  isAnyOf,\n  isAsyncThunkAction,\n  isFulfilled,\n  PayloadAction,\n  PayloadActionCreator,\n  Reducer,\n  Slice,\n  SliceCaseReducers,\n  TypedStartListening,\n} from '@reduxjs/toolkit';\nimport { initializeTrrack, Registry } from '@trrack/core';\n\nimport { isSliceTrrackable } from '../slice';\nimport {\n  ACTION_NAME_TYPE_MAP,\n  ASYNC_THUNKS,\n  DO_UNDO_ACTION_CREATORS,\n  GeneratedDoUndoActionCreators,\n  LabelGenerators,\n  LABELS,\n  NO_OP_ACTION,\n} from '../slice/types';\nimport { changeCurrent, getTrrackStore } from './trrackStore';\n\n// Fin.\n\nexport const trrackTraverseAction = createAction('traverse', function prepare<\n  T\n>(state: T) {\n  return {\n    payload: state,\n  };\n});\n\nfunction isTraverseAction(\n  action: AnyAction\n): action is ReturnType<typeof trrackTraverseAction> {\n  return action.type === trrackTraverseAction.type;\n}\n\nfunction makeTrrackable<State, A extends Action = AnyAction>(\n  reducer: Reducer<State, A>\n) {\n  return function (state: State | undefined, action: A) {\n    if (isTraverseAction(action))\n      return reducer(action.payload as State, action);\n    return reducer(state, action);\n  };\n}\n\nfunction mergeLabels(slices: Slice[]) {\n  return slices.reduce((acc, slice) => {\n    if (isSliceTrrackable(slice)) {\n      return { ...acc, ...slice[LABELS] };\n    }\n    return acc;\n  }, {} as LabelGenerators);\n}\n\nfunction mergeDoUndoActionCreators(slices: Slice[]) {\n  return slices.reduce((acc, slice) => {\n    if (isSliceTrrackable(slice)) {\n      return { ...acc, ...slice[DO_UNDO_ACTION_CREATORS] };\n    }\n    return acc;\n  }, {} as GeneratedDoUndoActionCreators);\n}\n\nfunction mergeReducerEventTypes(slices: Slice[]) {\n  return slices.reduce((acc, slice) => {\n    if (isSliceTrrackable(slice)) {\n      return { ...acc, ...slice[ACTION_NAME_TYPE_MAP] };\n    }\n    return acc;\n  }, {} as { [key: string]: string });\n}\n\nfunction mergeAsyncThunks(slices: Slice[]) {\n  return slices.reduce((acc, slice) => {\n    if (isSliceTrrackable(slice)) {\n      const asyncs: { [key: string]: AsyncThunk<any, any, any> } = {};\n\n      slice[ASYNC_THUNKS].forEach((thunk) => {\n        asyncs[thunk.typePrefix] = thunk;\n        asyncs[thunk.fulfilled.type] = thunk;\n      });\n\n      return { ...acc, ...asyncs };\n    }\n    return acc;\n  }, {} as { [key: string]: AsyncThunk<any, any, any> });\n}\n\nfunction mergeTrrackedActions(slices: Slice[]) {\n  return slices.reduce((acc, slice) => {\n    if (isSliceTrrackable(slice)) {\n      return [\n        ...acc,\n        ...(Object.values(slice.actions) as Array<PayloadActionCreator>),\n      ];\n    }\n    return acc;\n  }, [] as Array<PayloadActionCreator>);\n}\n\nfunction mergeReducers(slices: Slice[]) {\n  return slices.reduce((acc, slice) => {\n    const scr: SliceCaseReducers<any> = {};\n\n    Object.entries(slice.actions).forEach(([key, action]) => {\n      scr[action.type] = slice.caseReducers[key];\n    });\n\n    return { ...acc, ...scr };\n  }, {} as SliceCaseReducers<any>);\n}\n\nfunction mergeActionToSliceName(slices: Slice[]) {\n  return slices.reduce((acc, slice) => {\n    const scr: { [key: string]: string } = {};\n\n    Object.values(slice.actions).forEach((action) => {\n      scr[action.type] = slice.name;\n    });\n\n    return { ...acc, ...scr };\n  }, {} as { [key: string]: string });\n}\n\nexport function configureTrrackableStore<State>(\n  opts: ConfigureStoreOptions<State, AnyAction> & {\n    slices: Slice[];\n  }\n) {\n  const trrackMiddleware = createListenerMiddleware();\n\n  const _reducer = opts.reducer;\n\n  const store = configureStore({\n    ...opts,\n    reducer: makeTrrackable(\n      typeof _reducer === 'function'\n        ? _reducer\n        : (combineReducers(_reducer) as any)\n    ),\n    middleware(getDefaultMiddleware) {\n      const suppliedMiddleware = opts.middleware;\n      if (!suppliedMiddleware)\n        return getDefaultMiddleware().prepend(trrackMiddleware.middleware);\n      if (typeof suppliedMiddleware === 'function') {\n        return [\n          ...suppliedMiddleware(getDefaultMiddleware),\n          trrackMiddleware.middleware,\n        ];\n      }\n      return [...suppliedMiddleware, trrackMiddleware.middleware];\n    },\n  });\n\n  /**\n   * Create types for listener\n   */\n  type RootState = ReturnType<typeof store.getState>;\n  type AppDispatch = typeof store.dispatch;\n\n  type AppStartListening = TypedStartListening<RootState, AppDispatch>;\n  const startListening = trrackMiddleware.startListening as AppStartListening;\n  // Fin.\n\n  const labels = mergeLabels(opts.slices);\n  const doUndoActionCreators = mergeDoUndoActionCreators(opts.slices);\n  const reducerEventTypes = mergeReducerEventTypes(opts.slices);\n  const asyncThunks = mergeAsyncThunks(opts.slices);\n  const trrackedActions = mergeTrrackedActions(opts.slices);\n\n  const trrack = initializeTrrack({\n    initialState: store.getState(),\n    registry: Registry.create(),\n  });\n\n  let middlewareStatus: 'active' | 'paused' = 'active';\n\n  Object.values(asyncThunks).forEach((thunk) => {\n    if (!trrack.registry.has(thunk.typePrefix)) {\n      trrack.registry.register(thunk.typePrefix, (args: any) => {\n        middlewareStatus = 'paused';\n        const th = store.dispatch(thunk(args) as any);\n        return th.then(() => (middlewareStatus = 'active'));\n      });\n    }\n  });\n\n  opts.slices.forEach((slice) => {\n    Object.values(slice.actions).forEach((action) => {\n      trrack.registry.register(action.type, ((act: AnyAction) => {\n        return store.dispatch(act);\n      }) as any);\n    });\n  });\n\n  const trrackStore = getTrrackStore({\n    current: trrack.current.id,\n  });\n\n  trrack.currentChange(() => {\n    middlewareStatus = 'paused';\n    store.dispatch(trrackTraverseAction(trrack.getState()));\n    trrackStore.dispatch(changeCurrent(trrack.current.id));\n    middlewareStatus = 'active';\n  });\n\n  startListening({\n    predicate(action) {\n      if (trrack.isTraversing) return false; // Never run middleware when trrack is traversing.\n\n      if (middlewareStatus === 'paused') return false; // Never run middleware when middleware is set to pause.\n\n      // Check if given actions is fulfilled async thunk action and only then return true.\n      if (isAsyncThunkAction(action)) {\n        return isFulfilled(action);\n      }\n\n      // Run the middleware if the action is trracked, trrack is not traversing and middleware is not paused.\n      const isTrrackedAction = isAnyOf(trrackedActions[0], ...trrackedActions);\n      return isTrrackedAction(action);\n    },\n    effect(action, api) {\n      const isThunk = isFulfilled(action);\n\n      const type = isThunk ? asyncThunks[action.type].typePrefix : action.type;\n      const payload = action['payload'];\n      const labelGenerator = labels[type];\n\n      const label = labelGenerator(payload);\n\n      const doUndoObject = doUndoActionCreators[type]({\n        action: action as PayloadAction,\n        currentState: api.getState(),\n        previousState: api.getOriginalState(),\n      });\n\n      const hasSideEffects = !NO_OP_ACTION.match(doUndoObject.undo);\n\n      if (hasSideEffects) {\n        const undoAct = doUndoObject.undo as PayloadAction;\n        const doAct = NO_OP_ACTION.match(doUndoObject.do)\n          ? (action as PayloadAction)\n          : (doUndoObject.do as PayloadAction);\n\n        trrack.record({\n          label,\n          state: api.getState(),\n          eventType: reducerEventTypes[type],\n          sideEffects: {\n            do: [\n              {\n                type: isThunk ? type : doAct.type,\n                payload: isThunk ? doAct.payload : doAct,\n              },\n            ],\n            undo: [\n              {\n                type: undoAct.type,\n                payload: isThunk ? undoAct.payload : undoAct,\n              },\n            ],\n          },\n          onlySideEffects: true,\n        });\n      } else {\n        // ! Fix\n\n        trrack.record({\n          label,\n          state: api.getState(),\n          eventType: reducerEventTypes[type],\n          sideEffects: {\n            do: [],\n            undo: [],\n          },\n        });\n      }\n    },\n  });\n\n  return { store, trrack, trrackStore };\n}\n","import { createAction } from '@reduxjs/toolkit';\n\nimport { Middlewares, PossibleMiddleware } from './types';\n\nexport function isMiddlewareArray<State>(\n  middleware: PossibleMiddleware<State>\n): middleware is Middlewares<State> {\n  return Array.isArray(middleware);\n}\n\nexport function asyncDoUndoActionCreatorHelper<T>(type: string, payload: T) {\n  return createAction(type, function prepare(c: T) {\n    return {\n      payload: c,\n    };\n  })(payload);\n}\n"],"names":["NO_OP_ACTION","createAction","LABELS","DO_UNDO_ACTION_CREATORS","TRRACKABLE","EVENTS","ACTION_NAME_TYPE_MAP","ASYNC_THUNKS","createNameToTypeMap","slice","actionNameToType","key","action","normalizeLabelGenerators","suppliedLabelLikes","thunks","labelGenerators","thunk","suppliedLabelLike","createReducerEventTypes","suppliedEventTypes","reducerEventTypes","suppliedEventType","createDoUndoActionCreators","suppliedDoUndoActionCreators","duac","suppliedDoUndoActionCreator","act","args","doAct","undo","createTrrackableSlice","options","createSlice","labels","doUndoActioncreators","isSliceTrrackable","initialState","trrackSlice","_","changeCurrent","getTrrackStore","init","configureStore","trrackTraverseAction","state","isTraverseAction","makeTrrackable","reducer","mergeLabels","slices","acc","mergeDoUndoActionCreators","mergeReducerEventTypes","mergeAsyncThunks","asyncs","mergeTrrackedActions","configureTrrackableStore","opts","trrackMiddleware","createListenerMiddleware","_reducer","store","combineReducers","getDefaultMiddleware","suppliedMiddleware","startListening","doUndoActionCreators","asyncThunks","trrackedActions","trrack","initializeTrrack","Registry","middlewareStatus","trrackStore","isAsyncThunkAction","isFulfilled","isAnyOf","api","isThunk","type","payload","labelGenerator","label","doUndoObject","undoAct","isMiddlewareArray","middleware","asyncDoUndoActionCreatorHelper","c"],"mappings":"0UAsDa,MAAAA,EAAeC,eAAa,OAAO,EAiCnCC,EAAS,OAAO,OAAO,EACvBC,EAA0B,OAAO,yBAAyB,EAC1DC,EAAa,OAAO,YAAY,EAChCC,EAAS,OAAO,QAAQ,EACxBC,EAAuB,OAAO,sBAAsB,EACpDC,EAAe,OAAO,cAAc,EC/DjD,SAASC,EAGPC,EAAU,CACV,MAAMC,EAAmB,CAAA,EAElB,cAAA,QAAQD,EAAM,OAAO,EAAE,QAC5B,CAAC,CAACE,EAAKC,CAAM,IAGP,CACaF,EAAAC,CAAG,EAClBC,EAAO,IACX,CAAA,EAGKF,CACT,CAEA,SAASG,EAIPJ,EACAK,EACAC,EACiB,CACjB,MAAMC,EAAmC,CAAA,EAElC,OAAAD,EAAA,QAASE,GAAU,CACxB,MAAMN,EAAMM,EAAM,WACZC,EAAoBJ,EAAmBH,CAAG,EAEhD,GAAI,CAACO,EAAmB,CACNF,EAAAL,CAAG,EAAI,IAAMA,EAC7B,MACF,CAEI,GAAA,OAAOO,GAAsB,SAAU,CACzBF,EAAAL,CAAG,EAAI,IAAMO,EAC7B,MACF,CAEI,MAAA,OAAOA,GAAsB,aAC/BF,EAAgBL,CAAG,EAAIO,GAGnB,IAAI,MAAM,sCAAsCP,EAAI,SAAA,CAAU,EAAE,CAAA,CACvE,EAEM,OAAA,QAAQF,EAAM,OAAO,EAAE,QAC5B,CAAC,CAACE,EAAKC,CAAM,IAGP,CACE,MAAAM,EAAoBJ,EAAmBH,CAAG,EAEhD,GAAI,CAACO,EAAmB,CACtBF,EAAgBJ,EAAO,IAAI,EAAI,IAAMA,EAAO,KAC5C,MACF,CAEI,GAAA,OAAOM,GAAsB,SAAU,CACzBF,EAAAJ,EAAO,IAAI,EAAI,IAAMM,EACrC,MACF,CAEI,GAAA,OAAOA,GAAsB,WAAY,CAC3BF,EAAAJ,EAAO,IAAI,EAAIM,EAC/B,MACF,CAEA,MAAM,IAAI,MACR,sCAAsCP,EAAI,SAAA,CAAU,KAAKC,EAAO,IAAI,EAAA,CAExE,CAAA,EAGKI,CACT,CAEA,SAASG,EAKPV,EACAW,EACAL,EACwC,CACxC,MAAMM,EAAyB,CAAA,EAExB,OAAAN,EAAA,QAASE,GAAU,CACxB,MAAMN,EAAMM,EAAM,WACZK,EAAoBF,EAAmBT,CAAG,EAE3CW,EAGHD,EAAkBV,CAAG,EAAIW,EAFzBD,EAAkBV,CAAG,EAAIA,CAG3B,CACD,EAEM,OAAA,QAAQF,EAAM,OAAO,EAAE,QAC5B,CAAC,CAACE,EAAKC,CAAM,IAGP,CACE,MAAAU,EAAoBF,EAAmBT,CAAG,EAE3CW,EACkBD,EAAAT,EAAO,IAAI,EAAIU,EADID,EAAAT,EAAO,IAAI,EAAIA,EAAO,IAElE,CAAA,EAGKS,CACT,CAEA,SAASE,EAIPd,EACAe,EACAT,EAC+B,CAC/B,MAAMU,EAAsC,CAAA,EAErC,OAAAV,EAAA,QAASE,GAAU,CACxB,MAAMN,EAAMM,EAAM,WAEZS,EAA8BF,EAA6Bb,CAAG,EAEpE,GAAKe,EAQE,CACC,MAAAC,EAAOC,GAIP,CACJ,KAAM,CAAE,GAAIC,EAAO,KAAAC,CAAK,EAAIJ,EAA4BE,CAAI,EAErD,MAAA,CACL,GAAIC,GAAgB7B,EAAa,EACjC,KAAA8B,CAAA,CACF,EAGFL,EAAKd,CAAG,EAAIgB,CACd,KAvBkC,CAChC,MAAMA,EAAM,KACH,CACL,GAAI3B,EAAa,EACjB,KAAMA,EAAa,CAAA,GAGvByB,EAAKd,CAAG,EAAIgB,CAAA,CAgBd,CACD,EAEM,OAAA,QAAQlB,EAAM,OAAO,EAAE,QAC5B,CAAwD,CAACE,EAAKC,CAAM,IAG9D,CACE,MAAAc,EACJF,EAA6Bb,CAAa,EACvCe,EAQHD,EAAKb,EAAO,IAAI,EAAKgB,GAIf,CACJ,KAAM,CAAE,GAAIC,EAAO,KAAAC,CAAK,EAAIJ,EAA4BE,CAAI,EAErD,MAAA,CACL,GAAIC,GAAgB7B,EAAa,EACjC,KAAA8B,CAAA,CACF,EAjBGL,EAAAb,EAAO,IAAI,EAAI,KACX,CACL,GAAIZ,EAAa,EACjB,KAAMA,EAAa,CAAA,EAiB3B,CAAA,EAGKyB,CACT,CAEO,SAASM,EAMdC,EAMmD,CAC7C,MAAAvB,EAAQwB,cAAYD,CAAO,EAE3BtB,EACJF,EAAoBC,CAAK,EAErByB,EAASrB,EACbJ,EACAuB,EAAQ,QAAU,CAAC,EACnBA,EAAQ,aAAe,CAAC,CAAA,EAGpBX,EAAoBF,EACxBV,EACAuB,EAAQ,mBAAqB,CAAC,EAC9BA,EAAQ,aAAe,CAAC,CAAA,EAGpBG,EAAuBZ,EAC3Bd,EACAuB,EAAQ,sBAAwB,CAAC,EACjCA,EAAQ,aAAe,CAAC,CAAA,EAGnB,MAAA,CACL,GAAGvB,EACH,CAACP,CAAM,EAAGgC,EACV,CAAC7B,CAAM,EAAGgB,EACV,CAAClB,CAAuB,EAAGgC,EAC3B,CAAC/B,CAAU,EAAG,GACd,CAACE,CAAoB,EAAGI,EACxB,CAACH,CAAY,EAAGyB,EAAQ,aAAe,CAAC,CAAA,CAE5C,CCvQO,SAASI,EACd3B,EACoC,CAC7B,OAAAL,EAAaA,KAAcK,EAAQ,EAC5C,CCDA,MAAM4B,EAAiC,CACrC,QAAS,IACX,EAEMC,EAAcL,EAAAA,YAAY,CAC9B,KAAM,SACN,aAAAI,EACA,SAAU,CACR,cAAe,CAACE,EAAG3B,KAAmC,CACpD,QAASA,EAAO,OAAA,EAEpB,CACF,CAAC,EAEY,CAAE,cAAA4B,CAAc,EAAIF,EAAY,QAEtC,SAASG,EAAeC,EAAwB,CACrD,OAAOC,iBAAe,CACpB,QAASL,EAAY,QACrB,eAAgBI,CAAA,CACjB,CACH,CCQa,MAAAE,EAAuB3C,EAAAA,aAAa,WAAY,SAE3D4C,EAAU,CACH,MAAA,CACL,QAASA,CAAA,CAEb,CAAC,EAED,SAASC,EACPlC,EACmD,CAC5C,OAAAA,EAAO,OAASgC,EAAqB,IAC9C,CAEA,SAASG,EACPC,EACA,CACO,OAAA,SAAUH,EAA0BjC,EAAW,CACpD,OAAIkC,EAAiBlC,CAAM,EAClBoC,EAAQpC,EAAO,QAAkBA,CAAM,EACzCoC,EAAQH,EAAOjC,CAAM,CAAA,CAEhC,CAEA,SAASqC,EAAYC,EAAiB,CACpC,OAAOA,EAAO,OAAO,CAACC,EAAK1C,IACrB2B,EAAkB3B,CAAK,EAClB,CAAE,GAAG0C,EAAK,GAAG1C,EAAMP,CAAM,CAAE,EAE7BiD,EACN,CAAqB,CAAA,CAC1B,CAEA,SAASC,EAA0BF,EAAiB,CAClD,OAAOA,EAAO,OAAO,CAACC,EAAK1C,IACrB2B,EAAkB3B,CAAK,EAClB,CAAE,GAAG0C,EAAK,GAAG1C,EAAMN,CAAuB,CAAE,EAE9CgD,EACN,CAAmC,CAAA,CACxC,CAEA,SAASE,EAAuBH,EAAiB,CAC/C,OAAOA,EAAO,OAAO,CAACC,EAAK1C,IACrB2B,EAAkB3B,CAAK,EAClB,CAAE,GAAG0C,EAAK,GAAG1C,EAAMH,CAAoB,CAAE,EAE3C6C,EACN,CAA+B,CAAA,CACpC,CAEA,SAASG,EAAiBJ,EAAiB,CACzC,OAAOA,EAAO,OAAO,CAACC,EAAK1C,IAAU,CAC/B,GAAA2B,EAAkB3B,CAAK,EAAG,CAC5B,MAAM8C,EAAuD,CAAA,EAE7D,OAAA9C,EAAMF,CAAY,EAAE,QAASU,GAAU,CAC9BsC,EAAAtC,EAAM,UAAU,EAAIA,EACpBsC,EAAAtC,EAAM,UAAU,IAAI,EAAIA,CAAA,CAChC,EAEM,CAAE,GAAGkC,EAAK,GAAGI,EACtB,CACO,OAAAJ,CACT,EAAG,CAAkD,CAAA,CACvD,CAEA,SAASK,EAAqBN,EAAiB,CAC7C,OAAOA,EAAO,OAAO,CAACC,EAAK1C,IACrB2B,EAAkB3B,CAAK,EAClB,CACL,GAAG0C,EACH,GAAI,OAAO,OAAO1C,EAAM,OAAO,CAAA,EAG5B0C,EACN,CAAiC,CAAA,CACtC,CA0BO,SAASM,EACdC,EAGA,CACA,MAAMC,EAAmBC,EAAAA,2BAEnBC,EAAWH,EAAK,QAEhBI,EAAQnB,EAAAA,eAAe,CAC3B,GAAGe,EACH,QAASX,EACP,OAAOc,GAAa,WAChBA,EACCE,EAAAA,gBAAgBF,CAAQ,CAC/B,EACA,WAAWG,EAAsB,CAC/B,MAAMC,EAAqBP,EAAK,WAChC,OAAKO,EAED,OAAOA,GAAuB,WACzB,CACL,GAAGA,EAAmBD,CAAoB,EAC1CL,EAAiB,UAAA,EAGd,CAAC,GAAGM,EAAoBN,EAAiB,UAAU,EAPjDK,EAAqB,EAAE,QAAQL,EAAiB,UAAU,CAQrE,CAAA,CACD,EASKO,EAAiBP,EAAiB,eAGlCzB,EAASe,EAAYS,EAAK,MAAM,EAChCS,EAAuBf,EAA0BM,EAAK,MAAM,EAC5DrC,EAAoBgC,EAAuBK,EAAK,MAAM,EACtDU,EAAcd,EAAiBI,EAAK,MAAM,EAC1CW,EAAkBb,EAAqBE,EAAK,MAAM,EAElDY,EAASC,EAAAA,iBAAiB,CAC9B,aAAcT,EAAM,SAAS,EAC7B,SAAUU,WAAS,OAAO,CAAA,CAC3B,EAED,IAAIC,EAAwC,SAE5C,OAAO,OAAOL,CAAW,EAAE,QAASnD,GAAU,CACvCqD,EAAO,SAAS,IAAIrD,EAAM,UAAU,GACvCqD,EAAO,SAAS,SAASrD,EAAM,WAAaW,IACvB6C,EAAA,SACRX,EAAM,SAAS7C,EAAMW,CAAI,CAAQ,EAClC,KAAK,IAAO6C,EAAmB,QAAS,EACnD,CACH,CACD,EAEIf,EAAA,OAAO,QAASjD,GAAU,CAC7B,OAAO,OAAOA,EAAM,OAAO,EAAE,QAASG,GAAW,CAC/C0D,EAAO,SAAS,SAAS1D,EAAO,KAAQe,GAC/BmC,EAAM,SAASnC,CAAG,CAClB,CAAA,CACV,CAAA,CACF,EAED,MAAM+C,EAAcjC,EAAe,CACjC,QAAS6B,EAAO,QAAQ,EAAA,CACzB,EAED,OAAAA,EAAO,cAAc,IAAM,CACNG,EAAA,SACnBX,EAAM,SAASlB,EAAqB0B,EAAO,SAAA,CAAU,CAAC,EACtDI,EAAY,SAASlC,EAAc8B,EAAO,QAAQ,EAAE,CAAC,EAClCG,EAAA,QAAA,CACpB,EAEcP,EAAA,CACb,UAAUtD,EAAQ,CAGhB,OAFI0D,EAAO,cAEPG,IAAqB,SAAiB,GAGtCE,EAAAA,mBAAmB/D,CAAM,EACpBgE,EAAAA,YAAYhE,CAAM,EAIFiE,EAAAA,QAAQR,EAAgB,CAAC,EAAG,GAAGA,CAAe,EAC/CzD,CAAM,CAChC,EACA,OAAOA,EAAQkE,EAAK,CACZ,MAAAC,EAAUH,cAAYhE,CAAM,EAE5BoE,EAAOD,EAAUX,EAAYxD,EAAO,IAAI,EAAE,WAAaA,EAAO,KAC9DqE,EAAUrE,EAAO,QACjBsE,EAAiBhD,EAAO8C,CAAI,EAE5BG,EAAQD,EAAeD,CAAO,EAE9BG,EAAejB,EAAqBa,CAAI,EAAE,CAC9C,OAAApE,EACA,aAAckE,EAAI,SAAS,EAC3B,cAAeA,EAAI,iBAAiB,CAAA,CACrC,EAID,GAFuB,CAAC9E,EAAa,MAAMoF,EAAa,IAAI,EAExC,CAClB,MAAMC,EAAUD,EAAa,KACvBvD,EAAQ7B,EAAa,MAAMoF,EAAa,EAAE,EAC3CxE,EACAwE,EAAa,GAElBd,EAAO,OAAO,CACZ,MAAAa,EACA,MAAOL,EAAI,SAAS,EACpB,UAAWzD,EAAkB2D,CAAI,EACjC,YAAa,CACX,GAAI,CACF,CACE,KAAMD,EAAUC,EAAOnD,EAAM,KAC7B,QAASkD,EAAUlD,EAAM,QAAUA,CACrC,CACF,EACA,KAAM,CACJ,CACE,KAAMwD,EAAQ,KACd,QAASN,EAAUM,EAAQ,QAAUA,CACvC,CACF,CACF,EACA,gBAAiB,EAAA,CAClB,CAAA,MAIDf,EAAO,OAAO,CACZ,MAAAa,EACA,MAAOL,EAAI,SAAS,EACpB,UAAWzD,EAAkB2D,CAAI,EACjC,YAAa,CACX,GAAI,CAAC,EACL,KAAM,CAAC,CACT,CAAA,CACD,CAEL,CAAA,CACD,EAEM,CAAE,MAAAlB,EAAO,OAAAQ,EAAQ,YAAAI,EAC1B,CCpSO,SAASY,EACdC,EACkC,CAC3B,OAAA,MAAM,QAAQA,CAAU,CACjC,CAEgB,SAAAC,EAAkCR,EAAcC,EAAY,CAC1E,OAAOhF,eAAa+E,EAAM,SAAiBS,EAAM,CACxC,MAAA,CACL,QAASA,CAAA,CACX,CACD,EAAER,CAAO,CACZ"}